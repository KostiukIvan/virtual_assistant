import asyncio
import sounddevice as sd
import numpy as np
import io
from pydub import AudioSegment

from pkg.streaming_stt import StreamingSTT
from pkg.conversational_ai import ConversationalAI
from pkg.streaming_tts import StreamingTTS
from pkg.virtual_assistant import VirtualAssistant

# === AUDIO SETTINGS ===
SAMPLE_RATE = 16000
CHANNELS = 1
BLOCK_SIZE = 1024


async def microphone_task(va: VirtualAssistant):
    """Continuously capture mic audio and feed into VA."""
    loop = asyncio.get_event_loop()

    def callback(indata, frames, time, status):
        if status:
            print("Mic status:", status)
        audio_bytes = indata.copy().tobytes()
        # Schedule feeding audio in event loop safely
        asyncio.run_coroutine_threadsafe(va.feed_audio(audio_bytes), loop)

    with sd.InputStream(
        channels=CHANNELS,
        samplerate=SAMPLE_RATE,
        blocksize=BLOCK_SIZE,
        dtype="int16",
        callback=callback,
    ):
        print("üéôÔ∏è Microphone streaming started. Speak into mic...")
        while va._running:
            await asyncio.sleep(0.1)


async def speaker_task(va):
    """
    Continuously play audio chunks generated by TTS.
    Supports PCM (`int16`) or MP3 bytes.
    """
    loop = asyncio.get_event_loop()

    async def audio_callback(outdata, frames, time, status):
        outdata.fill(0)
        try:
            chunk = await va.get_audio_chunk(0.01)
            if not chunk:
                return

            # The chunk is now guaranteed to be raw PCM bytes
            samples = np.frombuffer(chunk, dtype=np.int16)

            outdata_len = min(len(samples), len(outdata))
            outdata[:outdata_len, 0] = samples[:outdata_len]

        except Exception as e:
            print("Speaker task playback error:", e)

    with sd.OutputStream(
        channels=CHANNELS,
        samplerate=SAMPLE_RATE,
        blocksize=BLOCK_SIZE,
        dtype="int16",
        callback=lambda outdata, frames, time, status: asyncio.run_coroutine_threadsafe(
            audio_callback(outdata, frames, time, status), loop
        ),
    ):
        print("üîä Speaker streaming started.")
        while va._running:
            await asyncio.sleep(0.1)

async def main():
    # Initialize VA with your real implementations
    va = VirtualAssistant(
        stt_class=StreamingSTT,
        ai_class=ConversationalAI,
        tts_class=StreamingTTS,
        stt_config={"sample_rate": SAMPLE_RATE},
        ai_config={"model_name": "gpt-4o-mini"},
        tts_config={"voice": "alloy"},
    )

    va.start()

    # Run microphone and speaker concurrently
    mic_task = asyncio.create_task(microphone_task(va))
    spk_task = asyncio.create_task(speaker_task(va))

    try:
        await asyncio.gather(mic_task, spk_task)
    except KeyboardInterrupt:
        print("\nüõë Stopping VA...")
    finally:
        await va.stop()

if __name__ == "__main__":
    asyncio.run(main())